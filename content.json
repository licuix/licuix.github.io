[{"title":"RobotFrameWork导入自定义库 ","date":"2018-07-23T09:48:24.000Z","path":"2018/07/23/RobotFrameWork导入自定义库/","text":"背景&nbsp;&nbsp;&nbsp;&nbsp;robotframework（后文简称“RF”）框架是一个成熟、稳定的第三方的自动化框架，我们在使用的过程中需要导入第三方库来完成接口测试的工作，但是有一些场景可能需要自己编写一些python库，导入到RF框架里，下文主要是介绍如何将自己编写的Python库导入到RF框架里； 操作 Python代码结构1，.py文件 导入库的代码处理逻辑等2，_init_文件 &nbsp;&nbsp;&nbsp;&nbsp; 初始化文件3，setup.py文件 &nbsp;&nbsp;&nbsp;&nbsp;安装文件","tags":[{"name":"-测试 -Python","slug":"测试-Python","permalink":"http://yoursite.com/tags/测试-Python/"}]},{"title":"接口测试","date":"2017-08-16T07:38:14.000Z","path":"2017/08/16/接口测试/","text":"","tags":[]},{"title":"Charles抓包工具配置","date":"2017-08-15T02:53:39.000Z","path":"2017/08/15/Charles抓包工具配置/","text":"简介作为测试工程师，应该对抓包工具并不陌生，因为你要真正深入的了解一个功能的实现、逻辑、原理，需要熟悉接口，并且要对接口的字段、参数很熟悉，这时就需要我们的抓包工具了，像Charles、Fiddler 都是目前比较常用的抓包工具，下面结合自己对Charles的使用，将Charles的配置记录一下…… 抓取web端的配置1，省略安装步骤； 2，打开菜单栏，选择‘Proxy’,勾选‘Mac OS X Proxy’，表示将系统代理设置通过此‘Proxy’. 3，设置网络的代理协议 打开系统偏好设置，查看当前网络的高级设置中的代理协议，将网页代理和安全网页代理勾选上，并且http和https被设置代理到127.0.0.1 端口号8888，保存并应用。 4,配置完上面的几步，应该是可以能抓到web页的请求了，只是https的请求还看不到request和response的内容，应该显示的是unknown，因为https的请求是加密过的，需要先安装Charles证书。将证书添加到系统钥匙串中，默认是不信任，需要改为信任此证书。 然后在Charles的SSL设置中将抓到的Https请求添加上。 6,根据上面的步骤配置完，应该是可以能够抓到http、https的请求的…… 移动端设备配置1，手机设置代理找到移动端的WiFi设置，设置手动代理，输入IP地址、端口8888注意：需要电脑和移动设备处于同一个局域网才行 2，手机安装证书 如果要抓取https请求，移动端需要安装Charles证书，浏览器访问地址 http://charlesproxy.com/getssl 安装证书并且信任证书 3，经过上面几步配置，移动端的请求应该也能被Charles抓取到的……","tags":[{"name":"测试","slug":"测试","permalink":"http://yoursite.com/tags/测试/"}]},{"title":"python 爬虫12306数据（初级）","date":"2017-07-24T13:39:17.000Z","path":"2017/07/24/python爬虫12306数据（初级）/","text":"简介 用Python爬取12306购票网站上的数据，并解析获取自己需要的数据，初级爬虫也就是完成这些功能，再高级的数据分析、数据处理方向我还需要继续努力… 实现步骤1，首先打开12306余票查询的界面 https://kyfw.12306.cn/otn/lcxxcx/init 等待插图 2，在浏览器中打开转包工具，输入出发地、目的地、出发日期查询，我们能够获取到整个查询过程中，网站请求的所有数据，从中找到我们需要的链接数据 https://kyfw.12306.cn/otn/lcxxcx/query?purpose_codes=ADULT&amp;queryDate=2017-07-24&amp;from_station=BJP&amp;to_station=XKS 等待插图 分析response的数据 等待插图 将数据以json串的格式返回出来 3，仔细分析查询接口的response数据，发现返回的城市列表并不是城市的中文名称，而是经过编码后的城市列表，我们要做的需要将城市编码和中文对应起来，方便后续使用； https://kyfw.12306.cn/otn/resources/js/framework/station_name.js 我目前的思路是将城市编码的对应关系以dictionary的形式保存起来，每次调用的时候，遍历就可以啦，由于编码还属于菜鸟级别，所以编写的代码仅限于能用，至于性能、简洁性等就不要考虑啦… 代码附上： def Station(): ssl._create_default_https_context = ssl._create_unverified_context stationlist_url = &apos;https://kyfw.12306.cn/otn/resources/js/framework/station_name.js&apos; req = request.Request(stationlist_url) with request.urlopen(req) as f: stationlist = f.read().decode() stations=stationlist.split(&apos;@&apos;) sta_dict={} for str_station in stations: str_sta=str_station.split(&apos;|&apos;) station_dict = {} if len(str_sta)&gt;1: station_dict[str_sta[1]]=str_sta[2] sta_dict.update(station_dict) else: pass return (sta_dict) 4，之后就是构造https请求需要传入的request的参数和headers数据了 from_station_name=input(&apos;请输入您的出发地:&apos;) to_station_name=input(&apos;请输入您的目的地:&apos;) date=input(&apos;请输入您的出发时间:&apos;) Station_List=Station() for (name,code) in Station_List.items(): if name==from_station_name: from_station=code if name==to_station_name: to_station=code url=getTrainUrl(date,from_station,to_station) req=request.Request(url) req.add_header(&apos;User-Agent&apos;,&apos;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.115 Safari/537.36&apos;) req.add_header(&apos;Cookie&apos;,&apos;__NRF=74C05F8DA4A54BAD8FE8C1858576401F; JSESSIONID=07C9A0B74083F3A180E8071886B47263; route=495c805987d0f5c8c84b14f60212447d; RAIL_EXPIRATION=1497577504826; RAIL_DEVICEID=n0Tv4aSltAPvIFcIdjtFwSIFrK1XaT60U6XSst8e3PkZVc8dFaq3JfvZRkB-rNdNsqNqxEL7wp56JqJbi3zUHKQ0g0QG2ULAu-AYPieOnWPNYDPJY9_pNQqYlp6df7FKSlQNRLB2IQkKxeKH9M-9bOSyEmRcirIA; RAIL_OkLJUJ=FDm1llvY3QyNEM5j6eXoCAA1pOBxbKtl; BIGipServeropn=1508901386.64545.0000; _jc_save_detail=true; current_captcha_type=Z; BIGipServerotn=686817802.50210.0000; BIGipServerpool_passport=267190794.50215.0000; _jc_save_fromStation=%u5317%u4EAC%2CBJP; _jc_save_toStation=%u6D4E%u5357%2CJNK; _jc_save_fromDate=2017-07-20; _jc_save_toDate=2017-07-20; _jc_save_wfdc_flag=dc&apos;) with request.urlopen(req) as f: str_data=f.read().decode() 5，解析接口返回的数据，从中获取自己需要的数据 代码等待…","tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"Windows 客户端安装/卸载","date":"2017-07-22T14:11:57.000Z","path":"2017/07/22/Windows 客户端安装:卸载/","text":"背景 最近公司开发一款安装在Windows系统上的client，除了保证每个功能模块功能正常外，还需要考虑Windows系统上client的安装/卸载、兼容性、安全性这些点，将这些测试点总结记录一下； 实施 安装/升级 1，有的pc上运行的客户端是需要开发环境的支持的，比如我们的客户端是需要.net 和vc2013环境的支持的，像xp系统，这些环境是需要自己安装的，而Windows7及以上版本的系统，是自带这些开发环境的； 2，安装exe程序，查看安装软件文本是否合理、专业（一般都是调用现成的组件，文本都一样） 3，是否强制升级，从低版本以及更低版本能否调用升级程序； 卸载 1，一般安装完client会有卸载client的入口，用开始菜单中的卸载client卸载； 2，在控制面板中卸载； 3，在第三方安全软件中卸载； 4，注意事项：卸载完查看安装目录，是否卸载干净；卸载完查看系统注册表，是否软件相关的注册信息卸载干净； 安全 由于证书或者签名的问题，很多软件会被第三方安全软件标记为可疑程序，需要安装几款常用安全软件验证，360安全卫士、百度卫士、腾讯电脑管家 1，下载的时候，exe程序可能会被浏览器标记为不安全； 2，安装的时候，可能会被安全软件拒绝、阻止安装操作等； 3，修改某些配置文件或写入系统文件时，会被安全软件拒绝或者阻止操作，这些都要注意； 兼容性由于Windows系统版本较多，市面上使用的分布也不确定，所以兼容性也要注意一下WindowsXP,Windows7,Windows8,Windows10 32位/64位","tags":[{"name":"测试","slug":"测试","permalink":"http://yoursite.com/tags/测试/"},{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]}]